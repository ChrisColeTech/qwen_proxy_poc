#!/usr/bin/env python3
"""
File Writer
Responsible for writing generated content to files
"""

import logging
from pathlib import Path
from typing import Optional


class FileWriter:
    """Handles file writing operations"""
    
    def __init__(self, output_path: str = "../../backend-v2", dry_run: bool = False):
        self.output_path = Path(output_path)
        self.dry_run = dry_run
        self.logger = logging.getLogger("file_writer")
        
        # Track written files for reporting
        self.written_files = []
    
    def write_file(self, relative_path: str, content: str, force: bool = False) -> bool:
        """Write content to a file"""
        file_path = self.output_path / relative_path
        
        if self.dry_run:
            self.logger.info(f"üîç [DRY RUN] Would write: {relative_path}")
            return True
        
        try:
            # Check if file exists and we're not forcing
            if file_path.exists() and not force:
                self.logger.warning(f"‚ö†Ô∏è File exists, skipping: {relative_path}")
                return False
            
            # Create directories as needed
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Add warning header to content
            content_with_warning = self._add_warning_header(content, relative_path)
            
            # Write content
            file_path.write_text(content_with_warning, encoding='utf-8')
            
            self.written_files.append(str(file_path))
            self.logger.info(f"üìù Written: {relative_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Failed to write {relative_path}: {e}")
            return False
    
    def ensure_directory(self, relative_path: str) -> bool:
        """Ensure a directory exists"""
        dir_path = self.output_path / relative_path
        
        if self.dry_run:
            self.logger.debug(f"üîç [DRY RUN] Would create directory: {relative_path}")
            return True
        
        try:
            dir_path.mkdir(parents=True, exist_ok=True)
            self.logger.debug(f"üìÅ Created directory: {relative_path}")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Failed to create directory {relative_path}: {e}")
            return False
    
    def get_written_files(self) -> list:
        """Get list of files that were written"""
        return self.written_files.copy()
    
    def clear_written_files(self):
        """Clear the list of written files"""
        self.written_files.clear()
    
    def get_stats(self) -> dict:
        """Get writing statistics"""
        return {
            'total_files': len(self.written_files),
            'dry_run': self.dry_run,
            'output_path': str(self.output_path)
        }
    
    def _add_warning_header(self, content: str, relative_path: str) -> str:
        """Add warning header to generated files"""
        file_ext = Path(relative_path).suffix.lower()
        
        if file_ext in ['.ts', '.js']:
            warning = """/*
 * ‚ö†Ô∏è  WARNING: GENERATED CODE - DO NOT MODIFY ‚ö†Ô∏è
 * 
 * This file is automatically generated by the backend code generator.
 * Any manual changes will be overwritten when the generator runs.
 * 
 * To make changes, modify the generator configuration files in:
 * /tools/backend-tools/backend-generator-v2/
 * 
 * Then re-run the generator to update this file.
 */

"""
        elif file_ext in ['.py']:
            warning = '''"""
‚ö†Ô∏è  WARNING: GENERATED CODE - DO NOT MODIFY ‚ö†Ô∏è

This file is automatically generated by the backend code generator.
Any manual changes will be overwritten when the generator runs.

To make changes, modify the generator configuration files in:
/tools/backend-tools/backend-generator-v2/

Then re-run the generator to update this file.
"""

'''
        elif file_ext in ['.md']:
            warning = """<!-- ‚ö†Ô∏è  WARNING: GENERATED CODE - DO NOT MODIFY ‚ö†Ô∏è -->
<!-- This file is automatically generated by the backend code generator. -->
<!-- Any manual changes will be overwritten when the generator runs. -->
<!-- To make changes, modify the generator configuration files in: -->
<!-- /tools/backend-tools/backend-generator-v2/ -->
<!-- Then re-run the generator to update this file. -->

"""
        elif file_ext in ['.json']:
            # For JSON files, we need to embed the warning as a comment field in the JSON structure
            # Since JSON doesn't support comments, we'll add it as a special property
            import json
            try:
                # Parse the JSON content
                json_content = json.loads(content)
                
                # Add warning as a special property at the top
                warning_obj = {
                    "_WARNING": "GENERATED CODE - DO NOT MODIFY",
                    "_GENERATED_BY": "Backend Generator v2",
                    "_INSTRUCTIONS": "To make changes, modify the generator configuration files in /tools/backend-tools/backend-generator-v2/ and re-run the generator"
                }
                
                # Create new JSON with warning at the top
                new_json = {**warning_obj, **json_content}
                return json.dumps(new_json, indent=2)
                
            except json.JSONDecodeError:
                # If it's not valid JSON, fall back to no warning to avoid breaking the file
                return content
        else:
            # Generic comment style for other file types
            warning = """# ‚ö†Ô∏è  WARNING: GENERATED CODE - DO NOT MODIFY ‚ö†Ô∏è
# This file is automatically generated by the backend code generator.
# Any manual changes will be overwritten when the generator runs.
# To make changes, modify the generator configuration files in:
# /tools/backend-tools/backend-generator-v2/
# Then re-run the generator to update this file.

"""
        
        return warning + content


class FilePathHelper:
    """Helper for generating consistent file paths"""
    
    @staticmethod
    def to_camel_case(snake_str: str) -> str:
        """Convert snake_case to camelCase"""
        components = snake_str.replace('-', '_').split('_')
        return components[0] + ''.join(word.capitalize() for word in components[1:])
    
    @staticmethod
    def to_pascal_case(snake_str: str) -> str:
        """Convert snake_case to PascalCase"""
        components = snake_str.replace('-', '_').split('_')
        return ''.join(word.capitalize() for word in components)
    
    @staticmethod
    def to_kebab_case(input_str: str) -> str:
        """Convert snake_case or camelCase to kebab-case"""
        # Handle camelCase to kebab-case
        import re
        # Insert hyphens before uppercase letters (for camelCase)
        s1 = re.sub('([a-z0-9])([A-Z])', r'\1-\2', input_str)
        # Replace underscores with hyphens (for snake_case)
        s2 = s1.replace('_', '-')
        return s2.lower()
    
    @staticmethod
    def get_model_path(entity: str) -> str:
        """Get path for model file"""
        return f"src/models/{entity}.ts"
    
    @staticmethod
    def get_service_path(entity_lower: str) -> str:
        """Get path for service file"""
        return f"src/services/{entity_lower}Service.ts"
    
    @staticmethod
    def get_routes_path(entities: str) -> str:
        """Get path for routes file using camelCase"""
        filename = FilePathHelper.to_camel_case(entities)
        return f"src/routes/{filename}.ts"
    
    @staticmethod
    def get_infrastructure_paths() -> dict:
        """Get paths for infrastructure files"""
        return {
            'database': 'src/utils/database.ts',
            'auth_middleware': 'src/middleware/auth.ts',
            'validation_middleware': 'src/middleware/validation.ts',
            'app': 'src/app.ts'
        }