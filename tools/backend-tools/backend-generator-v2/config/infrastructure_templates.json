{
  "description": "Templates for infrastructure files (database, middleware, app.ts)",
  "templates": {
    "database": {
      "path": "src/utils/database.ts",
      "template": "import { Pool } from 'pg';\n\nexport class Database {\n  private static instance: Database;\n  private pool: Pool;\n\n  private constructor() {\n    this.pool = new Pool({\n      connectionString: process.env.DATABASE_URL,\n      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n      max: 5,\n      min: 1,\n      idleTimeoutMillis: 10000,\n      connectionTimeoutMillis: 10000,\n      allowExitOnIdle: false,\n      keepAlive: true,\n      keepAliveInitialDelayMillis: 10000\n    });\n\n    this.pool.on('error', (err) => {\n      console.error('âŒ Database pool error:', err);\n      if (err.message && err.message.includes('termination')) {\n        console.log('ðŸ”„ Database connection terminated, pool will handle reconnection');\n      }\n    });\n\n    this.pool.on('connect', (client) => {\n      console.log('ðŸ”— Database client connected');\n      client.query('SET statement_timeout = 30000');\n    });\n\n    this.pool.on('remove', (client) => {\n      console.log('ðŸ”Œ Database client disconnected');\n    });\n  }\n\n  public static getInstance(): Database {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance;\n  }\n\n  async query(text: string, params?: any[]) {\n    let client;\n    try {\n      client = await this.pool.connect();\n      const result = await client.query(text, params);\n      return result;\n    } catch (error) {\n      console.error('âŒ Database query error:', error);\n      if (error.message && error.message.includes('termination')) {\n        console.log('ðŸ”„ Query failed due to connection termination, retrying...');\n        try {\n          const newClient = await this.pool.connect();\n          const result = await newClient.query(text, params);\n          newClient.release();\n          return result;\n        } catch (retryError) {\n          console.error('âŒ Retry also failed:', retryError);\n          throw retryError;\n        }\n      }\n      throw error;\n    } finally {\n      if (client) {\n        client.release();\n      }\n    }\n  }\n\n  async getPoolInfo() {\n    return {\n      totalCount: this.pool.totalCount,\n      idleCount: this.pool.idleCount,\n      waitingCount: this.pool.waitingCount\n    };\n  }\n\n  async close() {\n    await this.pool.end();\n  }\n}\n\nexport const db = Database.getInstance();\nexport default Database;"
    },
    
    "auth_middleware": {
      "path": "src/middleware/auth.ts",
      "template": "import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\nexport interface AuthenticatedRequest extends Request {\n  user?: {\n    id: string;\n    username: string;\n    email: string;\n  };\n  userId?: string;\n}\n\nexport const authenticate = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n  console.log(`ðŸ” Auth middleware: Processing authentication for ${req.method} ${req.path}`);\n  \n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    console.log('âŒ Auth middleware: No token provided');\n    return res.status(401).json({ error: 'Access token required' });\n  }\n\n  console.log(`ðŸ” Auth middleware: Token found, length: ${token.length}`);\n\n  jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key', (err: any, user: any) => {\n    if (err) {\n      console.log('âŒ Auth middleware: Token verification failed:', err.message);\n      return res.status(403).json({ error: 'Invalid token' });\n    }\n    \n    console.log('âœ… Auth middleware: Token verified successfully');\n    console.log('ðŸ” Auth middleware: Decoded user object:', JSON.stringify(user, null, 2));\n    console.log(`ðŸ” Auth middleware: User fields available: ${Object.keys(user).join(', ')}`);\n    \n    req.user = user;\n    req.userId = user.id;\n    \n    console.log(`âœ… Auth middleware: Setting req.userId to: ${req.userId}`);\n    console.log(`ðŸ” Auth middleware: req.user set to:`, JSON.stringify(req.user, null, 2));\n    \n    next();\n  });\n};\n\nexport const optionalAuth = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n  console.log(`ðŸ” Optional auth middleware: Processing for ${req.method} ${req.path}`);\n  \n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    console.log('â„¹ï¸  Optional auth middleware: No token provided, continuing without auth');\n    return next();\n  }\n\n  console.log(`ðŸ” Optional auth middleware: Token found, length: ${token.length}`);\n\n  jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key', (err: any, user: any) => {\n    if (!err) {\n      console.log('âœ… Optional auth middleware: Token verified successfully');\n      console.log('ðŸ” Optional auth middleware: Decoded user object:', JSON.stringify(user, null, 2));\n      console.log(`ðŸ” Optional auth middleware: User fields available: ${Object.keys(user).join(', ')}`);\n      \n      req.user = user;\n      req.userId = user.id;\n      \n      console.log(`âœ… Optional auth middleware: Setting req.userId to: ${req.userId}`);\n      console.log(`ðŸ” Optional auth middleware: req.user set to:`, JSON.stringify(req.user, null, 2));\n    } else {\n      console.log('âš ï¸  Optional auth middleware: Token verification failed, continuing without auth:', err.message);\n    }\n    next();\n  });\n};"
    },
    
    "validation_middleware": {
      "path": "src/middleware/validation.ts", 
      "template": "import { Request, Response, NextFunction } from 'express';\nimport { validationResult } from 'express-validator';\n\nexport const validate = (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  \n  if (!errors.isEmpty()) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      details: errors.array()\n    });\n  }\n  \n  next();\n};\n\nexport const validateSchema = (schema: any) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const { error } = schema.validate(req.body);\n    \n    if (error) {\n      return res.status(400).json({\n        error: 'Validation failed',\n        details: error.details\n      });\n    }\n    \n    next();\n  };\n};"
    },
    
    "swagger_setup": {
      "path": "src/config/swagger.ts",
      "template": "import swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\nimport { Express } from 'express';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst options: swaggerJsdoc.Options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'Generated Backend API',\n      description: 'API documentation generated by Backend Generator v2',\n      version: '1.0.0',\n    },\n    servers: [\n      {\n        url: 'http://localhost:3001',\n        description: 'Development server',\n      },\n    ],\n    components: {\n      securitySchemes: {\n        bearerAuth: {\n          type: 'http',\n          scheme: 'bearer',\n          bearerFormat: 'JWT',\n        },\n      },\n    },\n  },\n  apis: ['./src/routes/*.ts'], // Path to the API files\n};\n\n// Try to load pre-generated swagger.json if available\nlet swaggerSpec;\ntry {\n  const swaggerPath = path.join(process.cwd(), 'swagger.json');\n  if (fs.existsSync(swaggerPath)) {\n    swaggerSpec = JSON.parse(fs.readFileSync(swaggerPath, 'utf8'));\n    console.log('ðŸ“– Loaded pre-generated swagger specification');\n  } else {\n    swaggerSpec = swaggerJsdoc(options);\n    console.log('ðŸ“– Generated swagger specification from JSDoc');\n  }\n} catch (error) {\n  console.warn('âš ï¸  Failed to load swagger spec, falling back to JSDoc:', error.message);\n  swaggerSpec = swaggerJsdoc(options);\n}\n\nexport const setupSwagger = (app: Express): void => {\n  // Swagger UI setup\n  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {\n    customCss: '.swagger-ui .topbar { display: none }',\n    customSiteTitle: 'Generated Backend API Documentation',\n    swaggerOptions: {\n      persistAuthorization: true,\n    },\n  }));\n  \n  // Serve raw JSON spec\n  app.get('/api-docs.json', (req, res) => {\n    res.setHeader('Content-Type', 'application/json');\n    res.send(swaggerSpec);\n  });\n  \n  console.log('ðŸ“– Swagger documentation available at /api-docs');\n  console.log('ðŸ“„ Raw OpenAPI spec available at /api-docs.json');\n};\n\nexport { swaggerSpec };"
    },
    
    "app_template": {
      "path": "src/app.ts",
      "template": "import express from 'express';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport { setupSwagger } from './config/swagger';\n\n// Load environment variables\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.PORT || 3001;\n\n// Request logging middleware\napp.use((req, res, next) => {\n  console.log(`ðŸ“¥ ${new Date().toISOString()} - ${req.method} ${req.path}`);\n  if (req.body && Object.keys(req.body).length > 0) {\n    console.log(`   Body:`, JSON.stringify(req.body, null, 2));\n  }\n  if (req.query && Object.keys(req.query).length > 0) {\n    console.log(`   Query:`, JSON.stringify(req.query, null, 2));\n  }\n  next();\n});\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Root route redirect to Swagger documentation\napp.get('/', (req, res) => {\n  res.redirect('/api-docs');\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({ status: 'OK', timestamp: new Date().toISOString() });\n});\n\n// Setup Swagger documentation\nsetupSwagger(app);\n\n// Import route handlers\n{ROUTE_IMPORTS}\n\n// Register API routes\n{ROUTE_REGISTRATIONS}\n\n// Response logging middleware\napp.use((req, res, next) => {\n  const originalSend = res.send;\n  res.send = function(data) {\n    console.log(`ðŸ“¤ ${new Date().toISOString()} - ${req.method} ${req.path} - ${res.statusCode}`);\n    if (res.statusCode >= 400) {\n      console.log(`   Error Response:`, data);\n    }\n    return originalSend.call(this, data);\n  };\n  next();\n});\n\n// Error handling middleware\napp.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error('âŒ Internal Error:', err);\n  console.error('   Stack:', err.stack);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\nif (require.main === module) {\n  app.listen(PORT, () => {\n    console.log(`ðŸš€ Server running on port ${PORT}`);\n    console.log(`ðŸ“– API Documentation: http://localhost:${PORT}/api-docs`);\n    console.log(`ðŸ  Root URL redirects to documentation`);\n  });\n}\n\nexport default app;"
    },
    
    "package_dependencies": {
      "path": "package.json.template", 
      "template": "{\n  \"swagger-dependencies\": {\n    \"swagger-jsdoc\": \"^6.2.8\",\n    \"swagger-ui-express\": \"^4.6.3\",\n    \"@types/swagger-jsdoc\": \"^6.0.1\",\n    \"@types/swagger-ui-express\": \"^4.1.3\"\n  }\n}"
    }
  },
  
  "route_template": {
    "template": "import { Router } from 'express';\nimport { authenticate } from '../middleware/auth';\nimport { validate } from '../middleware/validation';\nimport { {SERVICE_CLASS} } from '../services/{service_name}Service';\nimport { {MODEL_IMPORTS} } from '../models/{MODEL_NAME}';\n\nconst router = Router();\nconst {service_instance} = new {SERVICE_CLASS}();\n\n{ROUTE_METHODS}\n\nexport default router;",
    
    "route_method_template": "// {METHOD} {PATH}\nrouter.{method}('{path}', {auth_middleware}async (req: any, res) => {\n  try {\n    const result = await {service_instance}.{handler}({parameters});\n    res.json({ success: true, data: result });\n  } catch (error: any) {\n    res.status(400).json({ success: false, error: error.message });\n  }\n});"
  },
  
  "model_template": {
    "template": "export interface {ENTITY}Response {\n{RESPONSE_PROPERTIES}\n}\n\nexport interface Create{ENTITY}Request {\n{CREATE_PROPERTIES}\n}\n\nexport interface Update{ENTITY}Request {\n{UPDATE_PROPERTIES}\n}"
  },
  
  "service_template": {
    "template": "import { v4 as uuidv4 } from 'uuid';\nimport { Database } from '../utils/database';\nimport { {MODEL_IMPORTS} } from '../models/{MODEL_NAME}';\n\nexport class {SERVICE_CLASS} {\n  private db = Database.getInstance();\n\n{SERVICE_METHODS}\n\n{FORMAT_METHOD}\n}"
  }
}