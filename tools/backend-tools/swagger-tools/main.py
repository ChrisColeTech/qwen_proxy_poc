#!/usr/bin/env python3
"""
Main Swagger Documentation Tool
Complete tool for generating and updating Swagger documentation
"""

import os
import sys
import argparse
import json
from pathlib import Path

# Add current directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from route_parser import TypeScriptRouteParser
from swagger_generator import SwaggerDocGenerator


def update_backend_swagger_config(swagger_doc: dict, backend_path: str):
    """Update the backend's swagger configuration with generated docs"""
    app_ts_path = os.path.join(backend_path, 'src', 'app.ts')
    
    if not os.path.exists(app_ts_path):
        print(f"‚ùå Backend app.ts not found: {app_ts_path}")
        return False
    
    try:
        with open(app_ts_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find the swagger options section
        start_marker = "const swaggerOptions = {"
        end_marker = "};\n\nconst specs = swaggerJsdoc(swaggerOptions);"
        
        start_idx = content.find(start_marker)
        end_idx = content.find(end_marker)
        
        if start_idx == -1 or end_idx == -1:
            print("‚ùå Could not find swagger configuration in app.ts")
            return False
        
        # Create new swagger options with enhanced paths
        def format_js_object(obj, indent=6):
            """Format object as JavaScript/TypeScript object literal"""
            import json
            import re
            json_str = json.dumps(obj, indent=indent)
            # Convert JSON to JS object literal by removing quotes around property names
            # Replace "key": with key: (unquoted property names)
            js_str = re.sub(r'"([a-zA-Z_][a-zA-Z0-9_]*)"\s*:', r'\1:', json_str)
            # Convert values to proper JS types
            js_str = js_str.replace('"true"', 'true').replace('"false"', 'false').replace('"null"', 'null')
            return js_str
        
        schemas_str = format_js_object(swagger_doc['components']['schemas'], 6)
        tags_str = format_js_object(swagger_doc.get('tags', []), 6)
        
        new_swagger_options = f"""const swaggerOptions = {{
  definition: {{
    openapi: '3.0.0',
    info: {{
      title: 'Chessboard Vanilla V2 API',
      version: '2.0.0',
      description: 'Comprehensive RESTful API for chess game, puzzles, learning, and user management',
      contact: {{
        name: 'API Support',
        url: 'https://github.com/ChrisColeTech/chessboard-vanilla-v2'
      }}
    }},
    servers: [
      {{
        url: process.env.NODE_ENV === 'production' 
          ? 'https://chessboard-vanilla-v2.onrender.com'
          : 'http://localhost:3001',
        description: process.env.NODE_ENV === 'production' ? 'Production server' : 'Development server'
      }}
    ],
    components: {{
      securitySchemes: {{
        bearerAuth: {{
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        }}
      }},
      schemas: {schemas_str}
    }},
    security: [
      {{
        bearerAuth: []
      }}
    ],
    tags: {tags_str}
  }},
  apis: ['./src/routes/*.ts', './src/app.ts'], // paths to files containing OpenAPI definitions
}}"""
        
        # Replace the swagger options
        new_content = content[:start_idx] + new_swagger_options + content[end_idx:]
        
        # Write back to file
        with open(app_ts_path, 'w', encoding='utf-8') as f:
            f.write(new_content)
        
        print(f"‚úÖ Updated swagger configuration in {app_ts_path}")
        return True
        
    except Exception as e:
        print(f"‚ùå Error updating backend config: {e}")
        return False


def generate_route_documentation_file(swagger_doc: dict, output_path: str):
    """Generate a TypeScript file with all route documentation"""
    doc_content = '''/**
 * Auto-generated Swagger/OpenAPI Documentation
 * Generated by: tools/backend-tools/swagger-tools/main.py
 * 
 * This file contains JSDoc comments for all API routes.
 * Import and use these comments in your route files.
 */

'''
    
    for path, methods in swagger_doc['paths'].items():
        for method, spec in methods.items():
            doc_content += f'''
/**
 * @swagger
 * {path}:
 *   {method}:
 *     tags: {json.dumps(spec.get('tags', []))}
 *     summary: {spec.get('summary', '')}
 *     description: {spec.get('description', '')}
'''
            
            if 'parameters' in spec:
                doc_content += " *     parameters:\n"
                for param in spec['parameters']:
                    doc_content += f'''
 *       - name: {param['name']}
 *         in: {param['in']}
 *         required: {str(param['required']).lower()}
 *         schema:
 *           type: {param['schema']['type']}
 *         description: {param.get('description', f'{param["name"]} parameter')}
'''
            
            if 'requestBody' in spec:
                doc_content += '''
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
'''
            
            doc_content += " *     responses:\n"
            for status, response in spec.get('responses', {}).items():
                doc_content += f'''
 *       {status}:
 *         description: {response.get('description', '')}
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ApiResponse'
'''
            
            doc_content += " */\n"
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(doc_content)


def main():
    parser = argparse.ArgumentParser(description='Generate Swagger documentation for TypeScript routes')
    parser.add_argument('--routes-dir', default='/Users/chris/Projects/llm-api-vault-v2/backend-v2/src/routes',
                       help='Directory containing TypeScript route files')
    parser.add_argument('--backend-path', default='/Users/chris/Projects/llm-api-vault-v2/backend-v2',
                       help='Path to backend directory')
    parser.add_argument('--output-dir', default='/Users/chris/Projects/llm-api-vault-v2/tools/backend-tools/swagger-tools',
                       help='Output directory for generated files')
    parser.add_argument('--update-backend', action='store_true',
                       help='Update backend swagger configuration with generated schemas')
    
    args = parser.parse_args()
    
    print("üöÄ Chessboard V2 Swagger Documentation Generator")
    print("=" * 60)
    
    try:
        # Initialize components
        route_parser = TypeScriptRouteParser()
        doc_generator = SwaggerDocGenerator()
        
        # Parse routes
        print(f"üìÇ Parsing routes from: {args.routes_dir}")
        parsed_routes = route_parser.parse_directory(args.routes_dir)
        
        total_routes = sum(len(data.get('routes', [])) for data in parsed_routes.values() if 'error' not in data)
        print(f"‚úÖ Parsed {len(parsed_routes)} files with {total_routes} total routes")
        
        # Generate documentation
        print("üìù Generating Swagger documentation...")
        swagger_doc = doc_generator.generate_documentation(parsed_routes)
        
        # Ensure output directory exists
        os.makedirs(args.output_dir, exist_ok=True)
        
        # Save generated files
        swagger_json_path = os.path.join(args.output_dir, 'generated_swagger.json')
        route_docs_path = os.path.join(args.output_dir, 'route_documentation.ts')
        summary_path = os.path.join(args.output_dir, 'generation_summary.json')
        
        # Save swagger JSON
        with open(swagger_json_path, 'w', encoding='utf-8') as f:
            json.dump(swagger_doc, f, indent=2, ensure_ascii=False)
        
        # Generate route documentation file
        generate_route_documentation_file(swagger_doc, route_docs_path)
        
        # Save generation summary
        summary = {
            'generated_at': datetime.now().isoformat(),
            'total_endpoints': len(swagger_doc['paths']),
            'total_tags': len(swagger_doc.get('tags', [])),
            'total_schemas': len(swagger_doc['components']['schemas']),
            'files_parsed': len(parsed_routes),
            'routes_by_file': {
                file_name: len(data.get('routes', []))
                for file_name, data in parsed_routes.items()
                if 'error' not in data
            }
        }
        
        with open(summary_path, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2, ensure_ascii=False)
        
        print(f"üíæ Generated files:")
        print(f"   üìÑ Swagger JSON: {swagger_json_path}")
        print(f"   üìÑ Route docs: {route_docs_path}")
        print(f"   üìÑ Summary: {summary_path}")
        
        # Update backend configuration if requested
        if args.update_backend:
            print("\nüîÑ Updating backend configuration...")
            if update_backend_swagger_config(swagger_doc, args.backend_path):
                print("‚úÖ Backend configuration updated successfully")
            else:
                print("‚ùå Failed to update backend configuration")
        
        # Print summary
        print(f"\nüìä Generation Summary:")
        print(f"   üìç Total endpoints: {len(swagger_doc['paths'])}")
        print(f"   üè∑Ô∏è  Tags: {len(swagger_doc.get('tags', []))}")
        print(f"   üìã Schemas: {len(swagger_doc['components']['schemas'])}")
        print(f"   üìÅ Files processed: {len(parsed_routes)}")
        
        print(f"\nüéØ Route breakdown:")
        for file_name, count in summary['routes_by_file'].items():
            print(f"   {file_name}.ts: {count} routes")
        
        print(f"\n‚ú® Documentation generation complete!")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    # Import datetime here to avoid issues when imported as module
    from datetime import datetime
    
    success = main()
    sys.exit(0 if success else 1)