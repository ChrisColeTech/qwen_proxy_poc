"""
Export Generator - Generates index file content from analyzed exports
Creates barrel export files with proper TypeScript syntax
"""

import os
from pathlib import Path
from typing import List, Set
from workflow_context import WorkflowContext, FileContext


class ExportGenerator:
    """
    Generates index file content based on analyzed exports and directory structure.
    Handles conflict resolution and proper TypeScript export syntax.
    """
    
    def __init__(self):
        self.header_comment = """/*
 * ⚠️  WARNING: GENERATED CODE - DO NOT MODIFY ⚠️
 * 
 * This file is automatically generated by the IndexGenerator.
 * Any manual changes will be overwritten when the generator runs.
 * 
 * To make changes, modify the generator in:
 * /tools/frontend-tools/index-generator-v2/
 * 
 * Then re-run the generator to update this file.
 */"""
    
    def generate_index_content(self, context: WorkflowContext, dir_path: str) -> str:
        """
        Generate the complete index file content for a directory.
        This is the main entry point for the export generator workflow stage.
        """
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return ""
        
        lines = [self.header_comment, ""]
        
        # Generate file exports
        file_exports = self._generate_file_exports(context, dir_path)
        if file_exports:
            lines.extend(file_exports)
            lines.append("")
        
        # Generate subdirectory exports
        subdir_exports = self._generate_subdirectory_exports(context, dir_path)
        if subdir_exports:
            lines.extend(subdir_exports)
            lines.append("")
        
        # Remove trailing empty lines
        while lines and lines[-1] == "":
            lines.pop()
        
        return "\n".join(lines) if lines else ""
    
    def _generate_file_exports(self, context: WorkflowContext, dir_path: str) -> List[str]:
        """Generate exports for direct files in the directory"""
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return []

        # Check for conflicts in this directory
        all_exports_in_dir = {}  # export_name -> list of files that export it
        for file_context in dir_context.files:
            if file_context.file_name.startswith('index.'):
                continue  # Skip index files
            for export in file_context.exports:
                if export.name not in all_exports_in_dir:
                    all_exports_in_dir[export.name] = []
                all_exports_in_dir[export.name].append(file_context.file_name_without_ext)

        # Check if we have conflicts
        has_conflicts = any(len(files) > 1 for files in all_exports_in_dir.values())

        exports = []

        for file_context in dir_context.files:
            file_exports = self._generate_exports_for_file(
                context,
                file_context,
                use_selective_exports=has_conflicts,
                all_exports_in_dir=all_exports_in_dir
            )
            exports.extend(file_exports)

        return exports
    
    def _generate_exports_for_file(self, context: WorkflowContext, file_context: FileContext, use_selective_exports: bool = False, all_exports_in_dir: dict = None) -> List[str]:
        """Generate export statements for a single file"""
        if not file_context.exports:
            return []

        file_name = file_context.file_name_without_ext
        exports = []

        # Collect named and default exports
        named_exports = [exp for exp in file_context.exports if exp.is_named and not exp.is_default]
        default_exports = [exp for exp in file_context.exports if exp.is_default]

        # Use selective exports if there are conflicts in the directory
        if use_selective_exports and all_exports_in_dir:
            # Only export non-conflicting named exports
            for export in named_exports:
                # Skip exports that conflict with other files
                if export.name in all_exports_in_dir and len(all_exports_in_dir[export.name]) > 1:
                    # This export conflicts - skip it or handle it specially
                    continue

                if export.is_type_only:
                    exports.append(f"export type {{ {export.name} }} from './{file_name}';")
                else:
                    exports.append(f"export {{ {export.name} }} from './{file_name}';")
        else:
            # Generate named exports - use export type * if all named exports are type-only
            if named_exports:
                all_named_are_type_only = all(exp.is_type_only for exp in named_exports)
                if all_named_are_type_only:
                    exports.append(f"export type * from './{file_name}';")
                else:
                    exports.append(f"export * from './{file_name}';")

        # Generate default exports (skip if same name as named export to avoid duplicates)
        named_export_names = {exp.name for exp in named_exports}
        for default_export in default_exports:
            export_name = default_export.name

            # Skip if we already exported this name as a named export
            if export_name in named_export_names:
                continue

            if default_export.is_type_only:
                exports.append(f"export type {{ default as {export_name} }} from './{file_name}';")
            else:
                exports.append(f"export {{ default as {export_name} }} from './{file_name}';")

        return exports
    
    def _check_for_export_conflicts(self, context: WorkflowContext, dir_path: str, current_file: FileContext) -> bool:
        """Check if there are naming conflicts between exports in the same directory"""
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return False
        
        # Skip conflict detection for index files to prevent circular references
        if current_file.file_name.startswith('index.'):
            return False
        
        # Get export names from current file
        current_export_names = {exp.name for exp in current_file.exports}
        
        # Check other files in the same directory for conflicts
        for other_file in dir_context.files:
            # Skip self and index files
            if (other_file.file_path != current_file.file_path and 
                not other_file.file_name.startswith('index.')):
                other_export_names = {exp.name for exp in other_file.exports}
                if current_export_names & other_export_names:  # Intersection check
                    return True
        
        return False
    
    def _sanitize_identifier(self, name: str) -> str:
        """Convert a filename to a valid JavaScript identifier"""
        import re
        # Replace dots, hyphens, and other invalid chars with underscores
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Ensure it doesn't start with a number
        if sanitized and sanitized[0].isdigit():
            sanitized = f"_{sanitized}"
        return sanitized
    
    def _directory_has_file_conflicts(self, context: WorkflowContext, dir_path: str) -> bool:
        """Check if directory has files that would conflict when exported together"""
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return False
        
        # Collect all export names from files in this directory
        all_export_names = {}  # export_name -> list of files that export it
        
        for file_context in dir_context.files:
            if file_context.file_name.startswith('index.'):
                continue  # Skip index files
                
            for export in file_context.exports:
                if export.name not in all_export_names:
                    all_export_names[export.name] = []
                all_export_names[export.name].append(file_context.file_name_without_ext)
        
        # Check if any export name appears in multiple files
        conflicting_exports = 0
        for export_name, files in all_export_names.items():
            if len(files) > 1:
                conflicting_exports += 1
        
        # Only skip directory if it has many conflicts or very problematic ones
        if conflicting_exports > 0:
            total_files = len(dir_context.files)
            conflict_ratio = conflicting_exports / max(len(all_export_names), 1)
            
            # Skip if more than 50% of exports conflict OR if it's a known problematic pattern
            if (conflict_ratio > 0.5 or 
                self._is_problematic_conflict_pattern(dir_path, all_export_names)):
                context.add_warning(
                    f"Directory has {conflicting_exports} export conflicts - skipping index generation", 
                    dir_path
                )
                return True
        
        return False
    
    def _is_problematic_conflict_pattern(self, dir_path: str, all_export_names: dict) -> bool:
        """Check if this directory has known problematic conflict patterns"""
        # Skip page action directories where all files export 'pageActions'
        if 'pageActions' in all_export_names and len(all_export_names['pageActions']) > 10:
            return True
        
        # Skip page instruction directories where all files export 'pageInstructions'  
        if 'pageInstructions' in all_export_names and len(all_export_names['pageInstructions']) > 10:
            return True
        
        # Skip directories where the same service is duplicated many times
        for export_name, files in all_export_names.items():
            if export_name.endswith('Service') and len(files) > 1:
                return True
                
        return False
    
    def _directory_has_cross_directory_conflicts(self, context: WorkflowContext, dir_path: str) -> bool:
        """
        Check if subdirectories of this directory would have export conflicts when re-exported together.
        This prevents creating parent index files that would cause TS2308 errors.
        """
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return False
        
        # Collect all export names from subdirectories that would be re-exported
        all_subdirectory_exports = {}  # export_name -> list of subdirs that export it
        
        for subdir in dir_context.subdirectories:
            subdir_path = os.path.join(dir_path, subdir).replace('\\', '/')
            subdir_context = context.directories.get(subdir_path)
            
            # Only consider subdirectories that have or will have index files
            if subdir_context and (subdir_context.has_index or self._would_generate_index_for_subdirectory(context, subdir_path)):
                # Get all exports that would be re-exported from this subdirectory
                subdirectory_export_names = self._get_subdirectory_export_names(context, subdir_path)
                
                for export_name in subdirectory_export_names:
                    if export_name not in all_subdirectory_exports:
                        all_subdirectory_exports[export_name] = []
                    all_subdirectory_exports[export_name].append(subdir)
        
        # Check for conflicts - any export name appearing in multiple subdirectories
        conflicting_exports = 0
        conflicted_names = []
        
        for export_name, subdirs in all_subdirectory_exports.items():
            if len(subdirs) > 1:
                conflicting_exports += 1
                conflicted_names.append(f"{export_name} (from {', '.join(subdirs)})")
        
        if conflicting_exports > 0:
            # Log the specific conflicts for debugging
            context.add_warning(
                f"Cross-directory conflicts detected: {'; '.join(conflicted_names[:3])}" + 
                (f" and {conflicting_exports - 3} more" if conflicting_exports > 3 else ""), 
                dir_path
            )
            return True
            
        return False
    
    def _directory_has_standalone_vs_subdir_conflicts(self, context: WorkflowContext, dir_path: str) -> bool:
        """
        Check if standalone files in this directory conflict with exports from subdirectories.
        This detects patterns like hooks/useAuth.ts conflicting with hooks/auth/useAuth.ts via hooks/auth/index.ts
        """
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return False
        
        # Get all export names from standalone files in this directory
        standalone_exports = set()
        for file_context in dir_context.files:
            # Skip index.ts files
            if file_context.file_name.lower() == 'index.ts':
                continue
            for export in file_context.exports:
                standalone_exports.add(export.name)
        
        if not standalone_exports:
            return False
        
        # Get all export names that would come from subdirectories
        subdirectory_exports = set()
        for subdir in dir_context.subdirectories:
            subdir_path = os.path.join(dir_path, subdir).replace('\\', '/')
            subdir_context = context.directories.get(subdir_path)
            
            # Only consider subdirectories that have or will have index files
            if subdir_context and (subdir_context.has_index or self._would_generate_index_for_subdirectory(context, subdir_path)):
                subdir_export_names = self._get_subdirectory_export_names(context, subdir_path)
                subdirectory_exports.update(subdir_export_names)
        
        # Check for conflicts between standalone files and subdirectory exports
        conflicts = standalone_exports.intersection(subdirectory_exports)
        if conflicts:
            context.add_warning(
                f"Standalone vs subdirectory conflicts detected: {', '.join(sorted(list(conflicts))[:5])}", 
                dir_path
            )
            return True
            
        return False
    
    def _would_generate_index_for_subdirectory(self, context: WorkflowContext, subdir_path: str) -> bool:
        """
        Determine if we would generate an index for a subdirectory without actually calling should_generate_index
        to avoid recursion. This is a simplified check for cross-directory conflict detection.
        """
        dir_context = context.directories.get(subdir_path)
        if not dir_context:
            return False
        
        # Basic criteria: has files or subdirectories, and not already conflicted
        has_content = len(dir_context.files) > 0 or len(dir_context.subdirectories) > 0
        
        # Quick conflict check - don't generate if it has obvious file conflicts
        if has_content and self._directory_has_file_conflicts(context, subdir_path):
            # But still generate if it's an essential directory
            if not self._is_essential_aggregating_directory(subdir_path):
                return False
        
        return has_content
    
    def _get_subdirectory_export_names(self, context: WorkflowContext, subdir_path: str) -> set:
        """Get all export names that would be re-exported from a subdirectory"""
        export_names = set()
        dir_context = context.directories.get(subdir_path)
        
        if not dir_context:
            return export_names
        
        # Add exports from direct files in the subdirectory
        for file_context in dir_context.files:
            for export in file_context.exports:
                export_names.add(export.name)
        
        # Add exports from nested subdirectories that would also be re-exported
        for nested_subdir in dir_context.subdirectories:
            nested_subdir_path = os.path.join(subdir_path, nested_subdir).replace('\\', '/')
            nested_context = context.directories.get(nested_subdir_path)
            
            if nested_context and (nested_context.has_index or self._would_generate_index_for_subdirectory(context, nested_subdir_path)):
                nested_exports = self._get_subdirectory_export_names(context, nested_subdir_path)
                export_names.update(nested_exports)
        
        return export_names
    
    def _is_essential_aggregating_directory(self, dir_path: str) -> bool:
        """Check if this is an essential top-level directory that other code depends on"""
        # Normalize path and get the directory name relative to src
        normalized_path = os.path.normpath(dir_path).replace('\\', '/')
        
        # Get the directory name relative to the src root
        parts = normalized_path.split('/src/')
        if len(parts) < 2:
            return False
        
        relative_path = parts[1]
        path_parts = relative_path.split('/')
        
        # Top-level directories that are essential aggregators
        essential_top_level = {
            'services', 'components', 'types', 'hooks', 'utils', 'constants', 
            'contexts', 'store', 'stores', 'lib', 'data', 'providers'
        }
        
        # If it's a top-level directory that's essential, never skip it
        if len(path_parts) == 1 and path_parts[0] in essential_top_level:
            return True
            
        return False
    
    def _generate_subdirectory_exports(self, context: WorkflowContext, dir_path: str) -> List[str]:
        """Generate exports for subdirectories with conflict-aware handling"""
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return []
        
        exports = []
        
        # Check if this is an essential directory with conflicts
        has_conflicts = (
            self._directory_has_cross_directory_conflicts(context, dir_path) or 
            self._directory_has_file_conflicts(context, dir_path) or
            self._directory_has_standalone_vs_subdir_conflicts(context, dir_path)
        )
        is_essential = self._is_essential_aggregating_directory(dir_path)
        
        # If essential directory has conflicts, use selective exports instead of export *
        if is_essential and has_conflicts:
            context.add_warning(
                f"Essential directory has conflicts - using selective exports instead of export *", 
                dir_path
            )
            return self._generate_selective_subdirectory_exports(context, dir_path)
        
        # Standard export * handling for non-conflicting directories
        for subdir in dir_context.subdirectories:
            subdir_path = os.path.join(dir_path, subdir).replace('\\', '/')
            subdir_context = context.directories.get(subdir_path)
            
            # Only export subdirectories that have index files OR will have index files generated
            if subdir_context and (subdir_context.has_index or self._would_generate_index_for_subdirectory(context, subdir_path)):
                # Check if subdirectory has interfaces with function signatures
                use_export_star = not context.should_use_export_type(subdir_path)
                
                if use_export_star:
                    exports.append(f"export * from './{subdir}';")
                else:
                    exports.append(f"export type * from './{subdir}';")
        
        return exports
    
    def _generate_selective_subdirectory_exports(self, context: WorkflowContext, dir_path: str) -> List[str]:
        """Generate selective named exports for conflicting essential directories"""
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return []
        
        exports = []
        all_exported_names = set()  # Track names to avoid duplicates
        
        # First, collect all export names from standalone files in this directory
        # These take precedence over subdirectory exports
        for file_context in dir_context.files:
            if file_context.file_name.lower() == 'index.ts':
                continue
            for export in file_context.exports:
                all_exported_names.add(export.name)
        
        for subdir in dir_context.subdirectories:
            subdir_path = os.path.join(dir_path, subdir).replace('\\', '/')
            subdir_context = context.directories.get(subdir_path)
            
            if subdir_context and (subdir_context.has_index or self._would_generate_index_for_subdirectory(context, subdir_path)):
                # Get exports from this subdirectory
                subdir_exports = self._get_subdirectory_export_names(context, subdir_path)
                
                # Only export names that haven't been exported yet (first wins)
                unique_exports = []
                for export_name in subdir_exports:
                    if export_name not in all_exported_names:
                        all_exported_names.add(export_name)
                        unique_exports.append(export_name)
                
                if unique_exports:
                    # Separate types from values for proper export syntax
                    type_exports = []
                    value_exports = []
                    
                    # Get the subdirectory context to check export types
                    for export_name in unique_exports:
                        # Check if this export is type-only based on the export info
                        is_type_only = self._is_export_type_only(context, subdir_path, export_name)
                        if is_type_only:
                            type_exports.append(export_name)
                        else:
                            value_exports.append(export_name)
                    
                    # Generate separate export statements for types and values
                    if value_exports:
                        export_list = ", ".join(value_exports)
                        exports.append(f"export {{ {export_list} }} from './{subdir}';")
                    
                    if type_exports:
                        export_list = ", ".join(type_exports)
                        exports.append(f"export type {{ {export_list} }} from './{subdir}';")
        
        return exports
    
    def _is_export_type_only(self, context: WorkflowContext, subdir_path: str, export_name: str) -> bool:
        """Check if a specific export is type-only"""
        subdir_context = context.directories.get(subdir_path)
        if not subdir_context:
            return False
        
        # Check all files in the subdirectory for this export
        for file_context in subdir_context.files:
            for export_info in file_context.exports:
                if export_info.name == export_name:
                    return export_info.is_type_only
        
        # If not found in direct files, check nested subdirectories
        for nested_subdir in subdir_context.subdirectories:
            nested_subdir_path = os.path.join(subdir_path, nested_subdir).replace('\\', '/')
            if self._is_export_type_only(context, nested_subdir_path, export_name):
                return True
        
        return False
    
    def write_index_file(self, dir_path: str, content: str) -> bool:
        """Write the generated content to an index.ts file"""
        if not content.strip():
            return False
        
        index_path = os.path.join(dir_path, 'index.ts')
        
        try:
            with open(index_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        except Exception as e:
            print(f"ERROR: Failed to write index file {index_path}: {e}")
            return False
    
    def should_generate_index(self, context: WorkflowContext, dir_path: str) -> bool:
        """Determine if an index file should be generated for a directory"""
        dir_context = context.directories.get(dir_path)
        if not dir_context:
            return False
        
        # Don't generate if directory has no exportable content
        if not dir_context.files and not dir_context.subdirectories:
            return False
        
        # Don't overwrite existing source index files (hand-written)
        if dir_context.has_index and self._is_source_index_file(dir_path):
            return False
        
        # Skip directories that would have export conflicts between files
        # BUT never skip top-level aggregating directories as other code depends on them
        if (self._directory_has_file_conflicts(context, dir_path) and 
            not self._is_essential_aggregating_directory(dir_path)):
            return False
        
        # NEW: Skip directories that would have cross-directory export conflicts
        # This prevents TS2308 errors when subdirectories export the same names
        if (self._directory_has_cross_directory_conflicts(context, dir_path) and 
            not self._is_essential_aggregating_directory(dir_path)):
            context.add_warning(
                f"Skipping index generation due to cross-directory export conflicts", 
                dir_path
            )
            return False
        
        # NEW: Skip directories that have standalone vs subdirectory export conflicts
        # This prevents TS2308 errors when standalone files conflict with subdirectory exports
        if (self._directory_has_standalone_vs_subdir_conflicts(context, dir_path) and 
            not self._is_essential_aggregating_directory(dir_path)):
            context.add_warning(
                f"Skipping index generation due to standalone vs subdirectory conflicts", 
                dir_path
            )
            return False
        
        return dir_context.needs_index
    
    def _is_source_index_file(self, dir_path: str) -> bool:
        """Check if existing index file appears to be hand-written (not generated)"""
        index_path = os.path.join(dir_path, 'index.ts')
        
        if not os.path.exists(index_path):
            return False
        
        try:
            with open(index_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            # If it has our generated header, it's not a source file
            if self.header_comment in content:
                return False
            
            # Check if this directory should have a barrel export based on file structure
            dir_context = self._get_directory_context_for_barrel_detection(dir_path)
            if self._should_be_barrel_export_directory(dir_context):
                # This directory should have a barrel export, so the existing index is likely wrong
                return False
            
            # Check if it looks like a simple barrel export file (likely generated)
            lines = [line.strip() for line in content.split('\n') if line.strip()]
            
            # If it's mostly export statements and comments, it's likely generated
            export_lines = 0
            comment_lines = 0
            for line in lines:
                if line.startswith('export ') or line.startswith('export{') or line.startswith('export*'):
                    export_lines += 1
                elif line.startswith('//') or line.startswith('/*') or line.startswith('*'):
                    comment_lines += 1
            
            total_content_lines = len(lines)
            if total_content_lines > 0 and (export_lines + comment_lines) / total_content_lines > 0.8:
                # More than 80% of lines are exports or comments - likely generated
                return False
            
            # Consider it a source file if it doesn't have our generated header
            # and doesn't look like a simple barrel export file
            return True
        
        except Exception:
            return True  # Err on the side of caution - don't overwrite
    
    def _get_directory_context_for_barrel_detection(self, dir_path: str):
        """Get directory context for barrel export detection"""
        # This is a simplified version - in a full implementation, 
        # we'd have access to the WorkflowContext
        try:
            files = []
            if os.path.exists(dir_path):
                for entry in os.listdir(dir_path):
                    entry_path = os.path.join(dir_path, entry)
                    if os.path.isfile(entry_path) and entry.endswith(('.ts', '.tsx')):
                        if not entry.startswith('index.'):
                            files.append(entry)
            return {'files': files, 'dir_path': dir_path}
        except Exception:
            return {'files': [], 'dir_path': dir_path}
    
    def _should_be_barrel_export_directory(self, dir_context):
        """Determine if a directory should have a barrel export based on its structure"""
        files = dir_context.get('files', [])
        dir_path = dir_context.get('dir_path', '')
        
        # Special case for type directories - they should almost always be barrel exports
        if 'types' in dir_path.lower():
            # If there's a .types.ts file, this should be a barrel export
            for file in files:
                if file.endswith('.types.ts'):
                    return True
        
        # If there are multiple TypeScript files, it should likely be a barrel export
        ts_files = [f for f in files if f.endswith(('.ts', '.tsx'))]
        if len(ts_files) >= 2:
            return True
            
        # If there's exactly one .types.ts file, it should be a barrel export
        types_files = [f for f in files if f.endswith('.types.ts')]
        if len(types_files) == 1:
            return True
            
        return False