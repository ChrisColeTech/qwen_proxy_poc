import type { ElectronAPI } from '@/types/electron-api'

export class ElectronService {
  private electronAPI: ElectronAPI | undefined

  constructor() {
    this.electronAPI = (window as Window).electronAPI
  }

  isAvailable(): boolean {
    return !!this.electronAPI
  }

  // Settings operations
  async saveSettings(settings: Record<string, unknown>): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.storage) {
      await this.electronAPI.storage.saveSettings(settings)
    }
  }

  async loadSettings(): Promise<Record<string, unknown> | null> {
    if (this.isAvailable() && this.electronAPI?.storage) {
      return await this.electronAPI.storage.loadSettings()
    }
    return null
  }

  // File operations
  async openFile(): Promise<{ path: string; content: string } | null> {
    if (this.isAvailable() && this.electronAPI?.file) {
      return await this.electronAPI.file.openFile()
    }
    return null
  }

  async saveFile(path: string, content: string): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.file) {
      return await this.electronAPI.file.saveFile(path, content)
    }
    return false
  }

  async saveFileAs(content: string): Promise<{ path: string; success: boolean } | null> {
    if (this.isAvailable() && this.electronAPI?.file) {
      return await this.electronAPI.file.saveFileAs(content)
    }
    return null
  }

  // File queue operations
  async saveFileQueue(queue: any[]): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.fileQueue) {
      await this.electronAPI.fileQueue.saveFileQueue(queue)
    }
  }

  async loadFileQueue(): Promise<any[] | null> {
    if (this.isAvailable() && this.electronAPI?.fileQueue) {
      return await this.electronAPI.fileQueue.loadFileQueue()
    }
    return null
  }

  async exportFileQueue(queue: any[]): Promise<string | null> {
    if (this.isAvailable() && this.electronAPI?.fileQueue) {
      return await this.electronAPI.fileQueue.exportFileQueue(queue)
    }
    return null
  }

  async importFileQueue(): Promise<any[] | null> {
    if (this.isAvailable() && this.electronAPI?.fileQueue) {
      return await this.electronAPI.fileQueue.importFileQueue()
    }
    return null
  }

  // Window operations
  async minimizeWindow(): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.window) {
      this.electronAPI.window.minimize()
    }
  }

  async maximizeWindow(): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.window) {
      this.electronAPI.window.maximize()
    }
  }

  closeWindow(): void {
    if (this.isAvailable() && this.electronAPI?.window) {
      this.electronAPI.window.close()
    }
  }

  async isMaximized(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.window) {
      return this.electronAPI.window.isMaximized()
    }
    return false
  }

  // Dialog operations
  async showSaveDialog(defaultPath?: string): Promise<string | null> {
    if (this.isAvailable() && this.electronAPI?.dialog) {
      return await this.electronAPI.dialog.showSaveDialog(defaultPath)
    }
    return null
  }

  async showOpenDialog(): Promise<string[] | null> {
    if (this.isAvailable() && this.electronAPI?.dialog) {
      return await this.electronAPI.dialog.showOpenDialog()
    }
    return null
  }

  async showMessageBox(message: string, type?: 'info' | 'warning' | 'error'): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.dialog) {
      await this.electronAPI.dialog.showMessageBox(message, type)
    }
  }

  // API Process Control
  async startApiProcess(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.startApiProcess) {
      return await this.electronAPI.startApiProcess()
    }
    return false
  }

  async stopApiProcess(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.stopApiProcess) {
      return await this.electronAPI.stopApiProcess()
    }
    return false
  }

  async restartApiProcess(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.restartApiProcess) {
      return await this.electronAPI.restartApiProcess()
    }
    return false
  }

  async getApiStatus(): Promise<{ isRunning: boolean; pid: number | null }> {
    if (this.isAvailable() && this.electronAPI?.getApiStatus) {
      return await this.electronAPI.getApiStatus()
    }
    return { isRunning: false, pid: null }
  }

  // Window State Change Listener
  onWindowStateChange(callback: (state: { isMaximized: boolean }) => void): () => void {
    if (this.isAvailable() && this.electronAPI?.onWindowStateChange) {
      return this.electronAPI.onWindowStateChange(callback)
    }
    return () => {} // Return no-op function
  }

  // App operations
  getVersion(): string {
    if (this.isAvailable() && this.electronAPI?.app) {
      return this.electronAPI.app.getVersion()
    }
    return '1.0.0'
  }

  getPath(): string {
    if (this.isAvailable() && this.electronAPI?.app) {
      return this.electronAPI.app.getPath()
    }
    return ''
  }

  // Development operations
  openDevTools(): void {
    if (this.isAvailable() && this.electronAPI?.dev) {
      this.electronAPI.dev.openDevTools()
    }
  }

  reload(): void {
    if (this.isAvailable() && this.electronAPI?.dev) {
      this.electronAPI.dev.reload()
    }
  }
}
